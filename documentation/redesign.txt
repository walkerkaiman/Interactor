// INTERACTOR // 
======================================================

1. Current Architecture Overview
-------------------------------

A. High-Level Structure
-----------------------
Your project is a modular, event-driven interaction system with a clear separation between backend and frontend, plus shared types/manifests for cross-layer consistency.

Key Directories:
- backend/: Node.js/TypeScript server, core logic, module loading, and orchestration.
- frontend/: React/TypeScript SPA, UI for managing modules, interactions, and system state.
- shared/: JSON manifests and type definitions for module contracts.
- config/: System and interaction configuration.
- Tests/: Automated tests for both backend and frontend.

B. Core Backend Components
-------------------------
1. Module System
   - Modules are the building blocks (input/output, trigger/streaming), each in its own folder under backend/src/modules/.
   - Naming Convention: <name>_trigger or <name>_streaming (e.g., osc_input_trigger, audio_output_trigger).
   - ModuleLoader.ts: Dynamically loads modules based on config, enforces classification rules, and manages their lifecycle.
   - BaseModule.ts, InputModuleBase.ts, OutputModuleBase.ts: Abstract base classes providing common interfaces and behaviors for modules.

2. Core Services
   - MessageRouter.ts: Central event bus for routing messages/events between modules.
   - Logger.ts: Multi-level logging (No Logging, OSC, Serial, Outputs, Verbose/Debug) for diagnostics and auditing.
   - SystemStats.ts: Tracks and exposes system performance metrics.

3. Configuration
   - config/interactions/interactions.json: Defines how modules interact (wiring, triggers, data flow).
   - config/sync_manifests.js: Keeps manifests in sync between backend and shared.

C. Module Design
----------------
- Self-contained: Each module has its own config, assets, and documentation (wiki.md).
- Assets: Kept within the module (e.g., audio files in audio_output/assets/audio/).
- Manifests: JSON files in shared/manifests/ describe module capabilities and contracts.

D. Frontend
-----------
- React SPA: UI for managing modules, editing interactions, viewing logs, and system state.
- State Management: Likely using custom hooks (useLogStore.ts, useModulesStore.ts).
- Component Structure: Modular, with pages for each major function (e.g., InteractionEditor.tsx, ModuleWikiPage.tsx).
- API Layer: frontend/src/api/ for REST/WebSocket communication with backend.

E. Testing
----------
- Backend: Jest/Vitest tests for core logic and modules.
- Frontend: Component and integration tests for UI and state.

2. Technical Specifications
--------------------------

A. Technologies Used
-------------------
- **Backend:** Node.js (>=14), TypeScript
- **Frontend:** React (with Vite), TypeScript
- **Testing:** Vitest (frontend/backend)
- **Configuration:** JSON (for module configs, manifests, and interaction wiring)
- **Documentation:** Markdown (wiki.md per module)

B. Communication Protocols
--------------------------
- **Frontend-Backend:**
  - REST API (for configuration, module management)
  - WebSocket (for real-time events, logs, and state updates)
- **Module I/O:**
  - OSC (Open Sound Control) for networked audio/control messages
  - Serial (for hardware integration)
  - HTTP (for web-based triggers/outputs)
  - DMX (for lighting control)

C. Data Formats
---------------
- **Module Manifests:** JSON, describing module type, capabilities, config schema, and assets
- **Interaction Wiring:** JSON, mapping triggers to outputs and defining data flow
- **Assets:** WAV (audio), CSV (DMX), images (PNG/JPG for module assets)

D. Module Interface Contracts
----------------------------
- **BaseModule:** Defines lifecycle methods (init, start, stop, destroy), event handlers, and config schema
- **Input/Output Modules:** Must implement trigger or streaming interfaces as per naming convention
- **Manifest Schema:** Each module must provide a manifest JSON describing:
  - Name, type (input/output, trigger/streaming)
  - Configurable parameters (with types, defaults, and validation)
  - Supported events/messages
  - Asset references

E. Configuration Formats
-----------------------
- **System/Interaction Config:** JSON files in config/ directory
- **Module Config:** JSON files within each module's directory
- **Sync Scripts:** Node.js scripts (e.g., sync_manifests.js) for keeping manifests/types in sync

F. Logging
----------
- **Levels:** No Logging, OSC, Serial, Outputs, Verbose/Debug
- **Format:** Timestamped, with module name, event type, and message details
- **Output:** Console, log files, and optionally frontend via WebSocket

G. Testing Frameworks
---------------------
- **Backend:** Vitest, Jest
- **Frontend:** Vitest (React Testing Library for components)
- **Test Organization:** Tests/ directory, mirroring backend/frontend structure

H. Deployment & OS Requirements
------------------------------
- **Supported OS:** Windows 10+ (primary), cross-platform support possible with Node.js
- **Node.js Version:** >=14
- **Frontend Build:** Vite for fast development and production builds
- **Start Scripts:** Batch files (start_interaction.bat, run_all_tests.bat) for Windows automation


3. Recommended Test Coverage
----------------------------

**Backend Tests:**
- ModuleLoader loads and validates all module types (input/output, trigger/streaming)
- MessageRouter routes messages correctly (one-to-one, one-to-many, many-to-one, many-to-many)
- Logger logs at all levels and outputs to correct destinations
- SystemStats reports accurate metrics under load
- Configuration validation for all supported schema formats
- Plugin loading, versioning, and error handling
- Hot reloading of modules and configuration
- Backward compatibility with legacy modules

**Frontend Tests:**
- Node-based UI: drag-and-drop, connection creation, and deletion
- Real-time validation and error feedback in the node editor
- Module settings forms auto-generated from manifests
- UI state synchronization with backend configuration
- Visual feedback for event flow simulation
- Accessibility and keyboard navigation in the node editor

**Integration & End-to-End Tests:**
- End-to-end flow: input module triggers output module via configured wiring
- Live editing of interactions in the node-based UI updates backend configuration
- Plugin installation and removal reflected in both backend and frontend
- System recovers gracefully from module/plugin errors
- Export/import of interaction graphs preserves all configuration
- Performance under high event/message throughput


4. Module Inventory: Input and Output Modules
---------------------------------------------

**Input Modules:**
- frames_input
- http_input
- osc_input
- serial_input
- time_input

**Output Modules:**
- audio_output
- dmx_output
- http_output
- osc_output


5. Core Component Features & Message Routing Strategies
------------------------------------------------------

A. Module System
---------------
- **Purpose:** Encapsulates all input/output logic as modular, pluggable units.
- **Features:**
  - Classification as input/output and trigger/streaming, enforcing clear roles.
  - Self-contained: Each module manages its own config, assets, and documentation.
  - Dynamic loading at runtime for extensibility and hot-swapping.
  - Common interface: Lifecycle methods, event handlers, config schema.
  - Manifest-driven: Each module provides a manifest describing capabilities, configuration, and events.

B. ModuleLoader
---------------
- **Purpose:** Discovers, validates, and instantiates modules based on configuration.
- **Features:**
  - Dependency management and correct load order.
  - Classification enforcement and validation.
  - Lifecycle management (init, start, stop, destroy).

C. MessageRouter (Event Bus)
----------------------------
- **Purpose:** Central hub for all inter-module communication, decoupling senders and receivers.
- **Features:**
  - **One-to-One Routing:** Directs a message from a single sender to a single receiver (e.g., a specific output module).
  - **One-to-Many Routing:** Broadcasts a message from one sender to multiple receivers (e.g., a trigger activating several outputs).
  - **Many-to-One Routing:** Aggregates messages from multiple senders to a single receiver (e.g., multiple inputs feeding a single output).
  - **Many-to-Many Routing:** Supports complex topologies as defined by the interaction wiring config.
  - Subscription model: Modules subscribe to event types or addresses.
  - Loose coupling: Modules only know about event types, not each other.
  - Event filtering and transformation before delivery.
  - Asynchronous, non-blocking delivery.

D. Logger
---------
- **Purpose:** Structured, multi-level logging for diagnostics, auditing, and debugging.
- **Features:**
  - Configurable levels: No Logging, OSC, Serial, Outputs, Verbose/Debug.
  - Contextual logs: Timestamps, module names, event types, message details.
  - Output to console, files, and optionally frontend via WebSocket.

E. SystemStats
--------------
- **Purpose:** Monitors and reports system performance and health metrics.
- **Features:**
  - Tracks CPU, memory, event throughput, and module health.
  - Exposes stats via API for real-time frontend monitoring.

F. Configuration System
----------------------
- **Purpose:** Centralizes all system, module, and interaction wiring configuration.
- **Features:**
  - Declarative wiring: JSON defines how modules are connected (who sends to whom, what triggers what).
  - Validation against manifests.
  - Hot reloading of configuration without system restart.

G. Design Strategies
--------------------
- **Event-Driven Architecture:** All communication routed through MessageRouter for decoupling and scalability.
- **Manifest-Driven Contracts:** Machine-readable manifests for validation, UI generation, and automation.
- **Loose Coupling:** Modules interact only via events/messages, not direct references.
- **Declarative Topology:** Wiring (one-to-one, one-to-many, many-to-one, many-to-many) defined in configuration, not code.
- **Plug-and-Play Extensibility:** New modules added with minimal core changes, as long as they conform to contracts.
- **Asynchronous Processing:** Non-blocking message routing and event handling for high throughput and responsiveness.


6. How Everything Works Together
-------------------------------
1. Startup: Backend loads config, initializes core services, and dynamically loads modules.
2. Module Registration: Each module registers with the MessageRouter and exposes its capabilities.
3. Interaction Wiring: Based on interactions.json, modules are connected (e.g., input triggers output).
4. Event Flow: Inputs (OSC, HTTP, Serial, etc.) generate events routed to outputs (audio, DMX, etc.) via the MessageRouter.
5. Frontend: Provides a UI for monitoring, configuring, and editing modules/interactions in real time.
6. Shared Contracts: Manifests and types ensure frontend and backend agree on module interfaces.

7. Redesign for Simplicity, Extensibility, and Maintainability
-------------------------------------------------------------

A. Simplification
-----------------
- Unified Module Interface: Collapse InputModuleBase and OutputModuleBase into a single ModuleBase with clear input/output roles as properties.
- Declarative Wiring: Move from imperative wiring in code to a fully declarative, schema-driven approach (YAML/JSON) for interactions.
- Reduce Boilerplate: Use code generation for module scaffolding and manifest creation.

**Open Design Decisions & Team Input:**
- What should the unified ModuleBase interface look like? (List required methods, properties, and extension points)
- What schema language should be used for declarative wiring? (JSON Schema, YAML, custom DSL?)
- How will code generation be integrated into the developer workflow? (CLI tool, npm script, IDE plugin?)
- How will backward compatibility with existing modules be handled?

B. Extensibility
----------------
- Plugin System: Adopt a true plugin architecture (e.g., using npm packages or dynamic imports) so modules can be added/removed without code changes.
- Hot Reloading: Support live reloading of modules and configs without restarting the backend.
- Schema-Driven UI: Auto-generate frontend forms and controls from module manifests using a standard schema (e.g., JSON Schema).

**Open Design Decisions & Team Input:**
- What plugin loading mechanism will be used? (npm packages, file system discovery, dynamic import, etc.)
- How will plugin versioning and compatibility be managed?
- What are the security implications of loading third-party plugins?
- What UI library or framework will be used for schema-driven forms? (React JSON Schema Form, custom solution, etc.)
- How will hot reloading be implemented for both modules and configuration?

C. Maintainability
------------------
- Strict Typing Across Layers: Use a shared TypeScript types package for all contracts (backend, frontend, manifests).
- Centralized Event Bus: Make the MessageRouter a first-class, observable service with clear event contracts.
- Documentation Automation: Generate module and system docs from code and manifests, ensuring up-to-date developer and AI assistant docs.
- Testing Harness: Provide a unified test runner and fixtures for both backend and frontend modules.

**Open Design Decisions & Team Input:**
- How will shared types be published and consumed across backend, frontend, and manifests? (Monorepo, npm package, symlinks, etc.)
- What event contract format will be used for the MessageRouter? (TypeScript interfaces, JSON Schema, etc.)
- What tools will be used for documentation automation? (Typedoc, custom scripts, etc.)
- What unified test runner will be adopted? (Vitest, Jest, custom, etc.)
- How will test fixtures and mocks be managed for cross-module/system tests?

D. Node-Based Interface for Interaction Configuration
-----------------------------------------------------
- Implement a full node-based (visual) interface in the frontend for configuring interactions between modules.
- **Features:**
  - Drag-and-drop nodes representing modules (inputs, outputs, triggers, streaming, etc.).
  - Visual connectors to define data flow and event routing (one-to-one, one-to-many, many-to-one, many-to-many).
  - Real-time validation of connections based on module manifests and allowed wiring.
  - Contextual menus for editing module settings, wiring properties, and interaction parameters.
  - Live preview and simulation of event flow for testing configurations before deployment.
  - Export/import of interaction graphs as JSON/YAML for versioning and sharing.

**Open Design Decisions & Team Input:**
- What node editor library or framework will be used? (React Flow, JointJS, custom solution, etc.)
- How will the node-based UI synchronize with the underlying configuration files?
- What validation rules and user feedback mechanisms are required?
- How will the UI handle very large or complex interaction graphs?
- What is the minimum viable product (MVP) for the node-based interface?


**Design Decision Log**
-----------------------
| Area                | Decision/Option Chosen | Rationale/Notes | Owner | Date |
|---------------------|-----------------------|-----------------|-------|------|
|                     |                       |                 |       |      |
|                     |                       |                 |       |      |

> Use this table to track key design decisions, options considered, and rationale as the team works through the redesign.

8. Example Redesign Structure (Mermaid Diagram)
-----------------------------------------------
graph TD
  subgraph Backend
    A[Core Services]
    B[Module Loader]
    C[Event Bus]
    D[Modules (Plugins)]
  end
  subgraph Frontend
    E[UI Shell]
    F[Auto-Generated Module Forms]
    G[Live Logs/Events]
  end
  subgraph Shared
    H[Types & Schemas]
    I[Manifests]
  end
  A --> B
  B --> D
  D --> C
  C --> D
  E --> F
  F --> I
  G --> C
  E --> G
  H --> A
  H --> E
  H --> D
  I --> D
  I --> F

9. Summary
----------
Your current system is modular, event-driven, and well-structured for extensibility. The main opportunities for improvement are:
- Unifying and simplifying module interfaces.
- Making wiring and configuration more declarative.
- Adopting a true plugin system for modules.
- Automating UI and documentation from shared schemas.
- Centralizing and strictly typing all contracts.

This would make the system easier to extend, maintain, and onboard new developers, while keeping the architecture clean and robust. 